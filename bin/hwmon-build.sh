#!/bin/bash

WARN=/tmp/warnings.$$
MAIL_FILE=/tmp/mail.$$
ERR=/tmp/error.$$

BRANCH=$(git branch | egrep "^\*" | cut -f2 -d' ')

PATH_X86=/opt/kernel/x86_64/gcc-8.2.0/usr/bin/
PATH_ARM=/opt/kernel/gcc-7.3.0-nolibc/arm-linux-gnueabi/bin
PATH_PPC=/opt/kernel/powerpc64/gcc-6.5.0/bin

export PATH=${PATH_X86}:${PATH_ARM}:${PATH_PPC}:${PATH}

errors=0
builds=0
seq=0

maxload=$(($(nproc) + 4))

bindir=$(cd $(dirname $0); pwd)
kdir=$(dirname ${bindir})/kconfig

send_mail()
{
	echo "From Guenter Roeck <linux@roeck-us.net>" > ${MAIL_FILE}
	echo "Subject: $1" >> ${MAIL_FILE}
	echo "MIME-Version: 1.0" >> ${MAIL_FILE}
	echo "Content-Transfer-Encoding: 8bit" >> ${MAIL_FILE}
	echo "Content-Type: text/plain; charset=utf-8" >> ${MAIL_FILE}
	echo >> ${MAIL_FILE}
	cat $2 >> ${MAIL_FILE}
	git send-email --quiet --to=linux@roeck-us.net \
		    --suppress-cc=all --confirm=never --no-chain-reply-to \
		    ${MAIL_FILE} >/dev/null 2>/dev/null
	rm -f ${MAIL_FILE}
}

doclean()
{
	local ARCH=$1
	local noclean

	pwd | grep buildbot >/dev/null 2>&1
	noclean=$?

	if [ ${noclean} -eq 0 ]
	then
		git clean -x -d -f -q
	else
		make ARCH=${ARCH} mrproper >/dev/null 2>&1
		rm -f kconfig
	fi
}

genconfig()
{
    local overlay=$1
    local CROSS=$2
    local ARCH=$3
    local what=$4
    local retval

    cp ${kdir}/kconfig.common kconfig
    cat ${kdir}/${overlay} >> kconfig

    if [ "${what}" = "m" ]
    then
	echo "CONFIG_MODULES=y" >> kconfig
	(cd drivers; \
	    grep "config SENSORS" $(find watchdog hwmon -name Kconfig) | \
		awk '{ printf "CONFIG_%s=m\n",$2; }') >> kconfig
    else
	# Add all sensors and watchdog drivers
	(cd drivers; \
	    grep "config SENSORS" $(find watchdog hwmon -name Kconfig) | \
		awk '{ printf "CONFIG_%s=y\n",$2; }') >> kconfig
    fi

    KCONFIG_ALLCONFIG=kconfig make ${CROSS} ARCH=${ARCH} allnoconfig >/dev/null 2>&1
    retval=$?
    # fix fallout, if any
    make ${CROSS} ARCH=${ARCH} oldnoconfig >/dev/null 2>&1

    return ${retval}
}

doit()
{
    local ARCH=$1
    local overlays=$(cd ${kdir}; ls kconfig.hwmon*)
    local files
    local sfiles
    local failed=0

    # We should be on the target directory, in the target branch

    case ${ARCH} in
    x86_64|i386)
	PREFIX="x86_64-linux-"
	;;
    arm)
	PREFIX="arm-linux-gnueabi-"
	;;
    powerpc)
	PREFIX="powerpc64-linux-"
	;;
    *)
	return 1
	;;
    esac

    CROSS="CROSS_COMPILE=${PREFIX}"

    rm -f ${ERR}
    touch ${ERR}
    doclean ${ARCH}
    for overlay in ${overlays}
    do
	echo "$(basename $0): build:${overlay} branch:${BRANCH} arch:${ARCH} prefix:${PREFIX}"

	genconfig ${overlay} ${CROSS} ${ARCH} m
	if [ $? -ne 0 ]
	then
		echo failed to configure noconfig:${overlay}:m for ${ARCH}
		continue
	fi

	builds=$(expr ${builds} + 1)
	# Run with warnings disabled to reduce noise.
	make ${CROSS} -j${maxload} -i ARCH=${ARCH} >/dev/null 2> >(tee ${ERR}.tmp >&2)
	failed=$(($? + ${failed}))

	cat ${ERR}.tmp >> ${ERR}

	# Repeat, this time build everything into kernel

	# doclean ${ARCH}
	genconfig ${overlay} ${CROSS} ${ARCH} y
	if [ $? -ne 0 ]
	then
		echo failed to configure noconfig:${overlay}:y for ${ARCH}
		continue
	fi

	builds=$(expr ${builds} + 1)
	make ${CROSS} -j${maxload} -i ARCH=${ARCH} >/dev/null 2> >(tee ${ERR}.tmp >&2)
	failed=$((${failed} + $?))
	cat ${ERR}.tmp >> ${ERR}
	rm -f ${ERR}.tmp
    done

    if [ ${failed} -ne 0 ]
    then
	errors=$(expr ${errors} + 1)
	echo "$(basename $0): branch:${BRANCH} arch:${ARCH} prefix:${PREFIX} failed"

	[ -s ${WARN} ] && {
	    echo "--------------------" >> ${WARN}
	}
	echo "Build: ${BRANCH}:${ARCH}" >> ${WARN}
	echo >> ${WARN}
	cat ${ERR} >> ${WARN}
	echo "--------------------" >> ${WARN}
	echo "Build: ${BRANCH}:${ARCH} failed"
	return 1
    fi

    # Check for warnings / errors only during first run
    if [ ${seq} -ne 0 ]
    then
	rm -f ${ERR}
        return 0
    fi

    seq=$((${seq} + 1))

    # For remaining tests use object files generated by last build

    # Repeat with W=1 C=1, but only for object files in 
    # drivers/hwmon and drivers/watchdog to reduce noise.
    # The odd redirect is to get error output to the console (for the
    # buildbot log) and into a file for the status email.

    files=$(find drivers/hwmon drivers/watchdog -name '*.o' |
			grep -v built-in.o | egrep -v 'mod.o$' |
			grep -v watchdog.o 2>/dev/null)
    rm -f ${files}
    make ${CROSS} -j${maxload} -i W=1 C=1 CHECK=/opt/buildbot/bin/sparse \
		ARCH=${ARCH} ${files} >/dev/null 2> >(tee ${ERR}.tmp >&2)
    egrep '^drivers/(hwmon|watchdog)' ${ERR}.tmp > ${WARN}.sparse 2>&1
    rm -f ${ERR}.tmp

    # Finally do another run with smatch.
    # Append smatch log messages to warning log.
    # Run smatch on all sources, and ignore errors from the build step.
    sfiles=$(find drivers/hwmon drivers/watchdog -name '*.c' |
			grep -v built-in.c |
			egrep -v '.mod.c$' | sed -e 's/\.c/.o/')
    rm -f ${sfiles} ${files}
    make C=1 -j${maxload} -i \
		    CHECK="/opt/buildbot/bin/smatch --project=kernel" \
		    ${sfiles} 2>/dev/null | tee ${WARN}.smatch.tmp
    egrep '(warn|error|info):' ${WARN}.smatch.tmp | \
				egrep -v "atomic\.h:.*ignoring unreachable code" | \
				egrep -v "bitops\.h:.*ignoring unreachable code" \
				> ${WARN}.smatch
    rm -f ${WARN}.smatch.tmp
    # egrep "drivers/{hwmon|watchdog}" ${ERR} > ${WARN}.tmp 2>&1
    if [ -s ${WARN}.smatch -o -s ${WARN}.sparse ]; then
	[ -s ${WARN} ] && {
		echo "--------------------" >> ${WARN}
	}
	echo "Build: ${BRANCH}:${ARCH}" >> ${WARN}
	echo >> ${WARN}
	[ -s ${WARN}.sparse ] && {
		echo "sparse log:" >> ${WARN}
	        cat ${WARN}.sparse >> ${WARN}
		echo "--------------------" >> ${WARN}
	}
	[ -s ${WARN}.smatch ] && {
		echo "smatch log:" >> ${WARN}
	        cat ${WARN}.smatch >> ${WARN}
	}
    fi
    rm -f ${WARN}.tmp ${ERR} ${WARN}.smatch

    return 0
}

retcode=0
for x in x86_64 i386 arm powerpc
do
    doit $x
    retcode=$(($? + ${retcode}))
    doclean $x
done

echo >> ${WARN}
echo "-----------------------" >> ${WARN}
echo "Total builds: ${builds} Total build errors: ${errors}" >> ${WARN}

send_mail "${BRANCH} build warnings and errors" ${WARN}

rm -f ${WARN} ${WARN}.smatch ${ERR}

exit ${retcode}
